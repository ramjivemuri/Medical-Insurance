# ------------------------------------------------------------# Medical Insurance Charge Prediction - Streamlit App# Trains model from scratch on each rerun (no .pkl needed)# ------------------------------------------------------------import warningswarnings.filterwarnings("ignore", category=FutureWarning)import pandas as pdimport numpy as npimport seaborn as snsimport matplotlib.pyplot as pltimport streamlit as st# Try XGBoost; fall back to RandomForest if not installedtry:    from xgboost import XGBRegressor    USE_XGB = Trueexcept Exception:    from sklearn.ensemble import RandomForestRegressor    USE_XGB = False# ----------------------------# 1. Load Data (cached)# ----------------------------@st.cache_datadef load_data(path: str = "medical_insurance.csv") -> pd.DataFrame:    df = pd.read_csv(path)    df = df.drop_duplicates().reset_index(drop=True)    return dfdf_raw = load_data()# ----------------------------# 2. Preprocess Data# ----------------------------def preprocess(df: pd.DataFrame) -> pd.DataFrame:    """Return encoded dataframe ready for modeling."""    df = df.copy()    # BMI Category    bins = [0, 18.5, 25, 30, float("inf")]    labels = ["Underweight", "Normal", "Overweight", "Obese"]    df["BMI_Category"] = pd.cut(df["bmi"], bins=bins, labels=labels, include_lowest=True)    # Binary encodes    df["sex"] = df["sex"].map({"female": 0, "male": 1})    df["smoker"] = df["smoker"].map({"no": 0, "yes": 1})    # Dummies    df_enc = pd.get_dummies(df, columns=["region", "BMI_Category"], drop_first=False)    return df_encdf_model = preprocess(df_raw)# Separate features / targetX = df_model.drop("charges", axis=1)y = df_model["charges"]# ----------------------------# 3. Train Model (each rerun)# ----------------------------with st.spinner("Training model..."):    if USE_XGB:        model = XGBRegressor(            n_estimators=300,            learning_rate=0.05,            max_depth=4,            subsample=0.9,            colsample_bytree=0.9,            random_state=42,            use_label_encoder=False,            eval_metric="rmse",        )    else:        # Fallback model        from sklearn.ensemble import RandomForestRegressor        model = RandomForestRegressor(            n_estimators=300,            random_state=42,            n_jobs=-1,        )    model.fit(X, y)st.success("Model trained successfully!")# ----------------------------# Sidebar Inputs# ----------------------------st.sidebar.header("Input Patient Data")age = st.sidebar.slider(    "Age",    min_value=int(df_raw["age"].min()),    max_value=int(df_raw["age"].max()),    value=30,)sex_option = st.sidebar.selectbox("Sex", ["Female", "Male"])bmi = st.sidebar.slider(    "BMI",    min_value=float(df_raw["bmi"].min()),    max_value=float(df_raw["bmi"].max()),    value=25.0,)children = st.sidebar.number_input(    "Number of Children", min_value=0, max_value=int(df_raw["children"].max()), value=0, step=1)smoker_option = st.sidebar.selectbox("Smoker", ["No", "Yes"])region_option = st.sidebar.selectbox(    "Region", [r.capitalize() for r in sorted(df_raw["region"].unique())])# ----------------------------# 4. Encode User Input# ----------------------------def bmi_to_cat(val: float) -> str:    if val < 18.5:        return "Underweight"    elif val < 25:        return "Normal"    elif val < 30:        return "Overweight"    else:        return "Obese"sex_val = 1 if sex_option == "Male" else 0smoker_val = 1 if smoker_option == "Yes" else 0region_val = region_option.lower()bmi_cat = bmi_to_cat(bmi)# Build input row with *all* model columnsinput_dict = {c: 0 for c in X.columns}input_dict["age"] = ageinput_dict["sex"] = sex_valinput_dict["bmi"] = bmiinput_dict["children"] = childreninput_dict["smoker"] = smoker_valregion_col = f"region_{region_val}"bmi_col = f"BMI_Category_{bmi_cat}"if region_col in input_dict:    input_dict[region_col] = 1if bmi_col in input_dict:    input_dict[bmi_col] = 1input_df = pd.DataFrame([input_dict], columns=X.columns)# ----------------------------# 5. Predict# ----------------------------pred_charge = float(model.predict(input_df)[0])st.subheader("Predicted Annual Insurance Charge")st.metric(label="USD", value=f"${pred_charge:,.2f}")# ----------------------------# 6. Optional EDA# ----------------------------st.markdown("---")st.subheader("Explore the Data")if st.checkbox("Show data sample"):    st.dataframe(df_raw.head())if st.checkbox("Distribution of Insurance Charges"):    fig, ax = plt.subplots(figsize=(6, 4))    sns.histplot(df_raw["charges"], kde=True, ax=ax, color="teal")    ax.set_xlabel("Charges")    st.pyplot(fig)if st.checkbox("Charges: Smokers vs Non-Smokers"):    fig, ax = plt.subplots(figsize=(6, 4))    sns.boxplot(x="smoker", y="charges", data=df_raw, ax=ax, palette="Set2")    ax.set_xlabel("Smoker (no/yes)")    st.pyplot(fig)if st.checkbox("BMI vs Charges (colored by smoker)"):    fig, ax = plt.subplots(figsize=(6, 4))    sns.scatterplot(        x="bmi", y="charges", hue="smoker", data=df_raw, palette="Set1", ax=ax, alpha=0.7    )    ax.set_xlabel("BMI")    st.pyplot(fig)if st.checkbox("Correlation Heatmap"):    fig, ax = plt.subplots(figsize=(8, 5))    corr = df_model.corr(numeric_only=True)    sns.heatmap(corr, cmap="coolwarm", center=0, ax=ax)    st.pyplot(fig)st.markdown("----")st.caption(    "Model retrains on each rerun. To improve speed for repeated interaction, "    "you can cache the trained model using `@st.cache_resource`.")